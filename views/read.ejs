<%- include('./partials/head', {
  pageTitle: 'Read â€¢ BookLantern',
  pageDescription: 'Read classic books in one clean reader â€” bookmarks, notes, and text-to-speech.',
  canonicalUrl: (typeof canonicalUrl !== 'undefined' ? canonicalUrl : '')
}) %>
<body>
  <%- include('./partials/navbar') %>

  <main class="stack" style="--gap:16px; padding:16px;">
    <%- include('./partials/backLink', { referrer }) %>
    <h1 id="title">Book Title</h1>

    <div class="actions row" style="gap:8px; flex-wrap:wrap;">
      <button class="btn" id="btnBookmark" type="button">ðŸ”– Bookmark</button>
      <button class="btn" id="btnNotes" type="button">ðŸ—’ Notes</button>
      <button class="btn" id="btnListen" type="button" aria-pressed="false">ðŸ”Š Listen</button>
    </div>

    <div id="reader" class="card" style="min-height:70vh; overflow:auto; padding:0;"></div>
    <div id="fallback" class="card" style="display:none; padding:16px;">Loading book...</div>

    <!-- Notes -->
    <section class="card" style="margin-top:16px; padding:12px;">
      <h3 style="margin-top:0;">Your Notes</h3>
      <div class="row" style="gap:8px; margin-bottom:8px;">
        <input id="noteInput" class="input" type="text" placeholder="Write your notes hereâ€¦" style="flex:1; min-width:220px;">
        <button id="saveNote" class="btn" type="button">Save Note</button>
      </div>
      <ul id="notesList" class="stack" style="--gap:6px; margin:0; padding-left:18px;"></ul>
    </section>
  </main>

  <%- include('./partials/footer') %>

  <script defer src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>
  <script>
  (function () {
    const provider = "<%= provider %>";
    const id = "<%= id %>";
    const KEY_POS   = `bl:pos:${provider}:${id}`;
    const KEY_NOTES = `bl:notes:${provider}:${id}`;

    const titleEl = document.getElementById('title');
    const mount   = document.getElementById('reader');
    const fallback= document.getElementById('fallback');

    const btnBookmark = document.getElementById('btnBookmark');
    const btnListen   = document.getElementById('btnListen');
    const btnNotes    = document.getElementById('btnNotes');

    const noteInput = document.getElementById('noteInput');
    const saveNote  = document.getElementById('saveNote');
    const notesList = document.getElementById('notesList');

    // ---- Fetch book payload
    fetch(`/api/book?provider=${encodeURIComponent(provider)}&id=${encodeURIComponent(id)}`)
      .then(r => r.json())
      .then(data => initReader(data))
      .catch(() => showFallback('Network error'));

    function showFallback(msg){
      fallback.textContent = msg || 'Loading book...';
      fallback.style.display = 'block';
      mount.style.display = 'none';
    }

    function initReader(data){
      titleEl.textContent = [data?.title, data?.author].filter(Boolean).join(' â€” ') || 'Book';

      if (data?.type === 'epub' && data?.epubUrl){
        try {
          const book = ePub(data.epubUrl);
          const rendition = book.renderTo(mount, { width: "100%", height: "75vh", spread: "always" });

          const saved = getSavedPos();
          if (saved && saved.type === 'cfi' && saved.cfi) rendition.display(saved.cfi);
          else rendition.display();

          rendition.on('relocated', loc => {
            const cfi = loc?.start?.cfi;
            if (cfi) localStorage.setItem(KEY_POS, JSON.stringify({ type:'cfi', cfi, ts:Date.now() }));
          });

          btnBookmark.addEventListener('click', () => {
            const cfi = rendition.currentLocation()?.start?.cfi;
            if (cfi){
              localStorage.setItem(KEY_POS, JSON.stringify({ type:'cfi', cfi, ts:Date.now() }));
              flash('Bookmark saved');
            }
          });
        } catch(e){ showFallback('Unable to render EPUB.'); }
        return;
      }

      // HTML / Text
      mount.style.padding = '16px';
      if (data?.type === 'text'){
        mount.innerHTML = `<pre style="white-space:pre-wrap;word-wrap:break-word;">${escapeHtml(data.content||'')}</pre>`;
      } else if (data?.type === 'html'){
        mount.innerHTML = data.content || '<p>Not available.</p>';
      } else {
        showFallback('Book not available.');
        return;
      }

      // scroll save/restore
      const saved = getSavedPos();
      if (saved && saved.type === 'scroll' && typeof saved.y === 'number') mount.scrollTop = saved.y;
      mount.addEventListener('scroll', throttle(() => {
        localStorage.setItem(KEY_POS, JSON.stringify({ type:'scroll', y: mount.scrollTop, ts:Date.now() }));
      }, 400));
    }

    function getSavedPos(){ try { return JSON.parse(localStorage.getItem(KEY_POS)||'null'); } catch { return null; } }

    // Notes (local)
    function loadNotes(){ try { return JSON.parse(localStorage.getItem(KEY_NOTES)||'[]'); } catch { return []; } }
    function saveNotes(n){ localStorage.setItem(KEY_NOTES, JSON.stringify(n)); }
    function renderNotes(){
      const arr = loadNotes();
      notesList.innerHTML = arr.length ? '' : '<li style="opacity:.75;">No notes yet.</li>';
      arr.forEach((n, i) => {
        const li = document.createElement('li');
        li.innerHTML = `<span>${escapeHtml(n.text)}</span> <button class="btn" data-del="${i}" style="padding:2px 8px;margin-left:8px;">Delete</button>`;
        notesList.appendChild(li);
      });
    }
    saveNote.addEventListener('click', () => {
      const val = (noteInput.value||'').trim(); if (!val) return;
      const arr = loadNotes(); arr.push({ text: val, ts: Date.now() }); saveNotes(arr); noteInput.value=''; renderNotes(); flash('Note saved');
    });
    notesList.addEventListener('click', e => {
      const btn = e.target.closest('button[data-del]'); if (!btn) return;
      const idx = +btn.getAttribute('data-del'); const arr = loadNotes();
      if (idx>=0 && idx < arr.length){ arr.splice(idx,1); saveNotes(arr); renderNotes(); }
    });
    renderNotes();

    // Listen (simple)
    let speaking=false, paused=false, utter=null;
    btnListen.addEventListener('click', () => {
      if (!('speechSynthesis' in window)) return flash('Text-to-speech not supported.');
      if (speaking){ paused ? speechSynthesis.resume() : speechSynthesis.pause(); paused = !paused; btnListen.textContent = paused ? 'â¸ Paused' : 'ðŸ”Š Listen'; return; }
      const text = mount.textContent?.trim(); if (!text) return flash('Load content first.');
      speechSynthesis.cancel(); utter = new SpeechSynthesisUtterance(text); utter.rate=1;
      utter.onstart = ()=>{ speaking=true; btnListen.textContent='â¸ Paused'; };
      utter.onend   = ()=>{ speaking=false; paused=false; btnListen.textContent='ðŸ”Š Listen'; };
      utter.onerror = ()=>{ speaking=false; paused=false; btnListen.textContent='ðŸ”Š Listen'; };
      speechSynthesis.speak(utter);
    });

    // utils
    function flash(msg){
      const el=document.createElement('div');
      el.textContent=msg; Object.assign(el.style,{position:'fixed',right:'16px',bottom:'16px',padding:'10px 12px',borderRadius:'12px',background:'rgba(0,0,0,.75)',color:'#fff',zIndex:9999,boxShadow:'0 6px 20px rgba(0,0,0,.25)'}); document.body.appendChild(el); setTimeout(()=>el.remove(),1500);
    }
    function escapeHtml(s){return String(s).replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));}
    function throttle(fn, wait){ let t=0; return function(){ const n=Date.now(); if(n-t>wait){ t=n; fn.apply(this,arguments);} }; }
  })();
  </script>
</body>
</html>
