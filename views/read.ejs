<!doctype html>
<html lang="en">
<head>
  <%- include('./partials/head', {
    pageTitle: 'Read • BookLantern',
    pageDescription: 'Read classic books in one clean reader — bookmarks, notes, and text-to-speech.',
    canonicalUrl: (typeof canonicalUrl !== 'undefined' ? canonicalUrl : '')
  }) %>

  <!-- Supabase browser SDK (safe: if keys are missing, we no-op) -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    (function () {
      // These will be empty strings if not passed from server; the guards below avoid errors.
      var SB_URL  = "<%= (process.env && process.env.SUPABASE_URL) ? process.env.SUPABASE_URL : '' %>";
      var SB_ANON = "<%= (process.env && process.env.SUPABASE_ANON_KEY) ? process.env.SUPABASE_ANON_KEY : '' %>";

      if (SB_URL && SB_ANON && window.supabase) {
        try {
          window.supabaseClient = window.supabase.createClient(SB_URL, SB_ANON);
        } catch (_) { /* ignore */ }
      }
    })();
  </script>
</head>
<body>
  <%- include('./partials/navbar') %>

  <main class="stack" style="--gap:16px; padding:16px;">
    <% var __safeRef = (typeof referrer !== 'undefined' ? referrer : null); %>
    <%- include('./partials/backLink', { referrer: __safeRef }) %>

    <h1 id="title">Book Title</h1>

    <div class="actions row" style="gap:8px; flex-wrap:wrap;">
      <button class="btn" id="btnBookmark" type="button">🔖 Bookmark</button>
      <button class="btn" id="btnNotes" type="button">🗒 Notes</button>
      <button class="btn" id="btnListen" type="button" aria-pressed="false">🔊 Listen</button>
    </div>

    <div id="reader" class="card" style="min-height:70vh; overflow:auto; padding:0;"></div>
    <div id="fallback" class="card" style="display:none; padding:16px;">Loading book...</div>

    <!-- Notes -->
    <section class="card" style="margin-top:16px; padding:12px;">
      <h3 style="margin-top:0;">Your Notes</h3>
      <div class="row" style="gap:8px; margin-bottom:8px;">
        <input id="noteInput" class="input" type="text" placeholder="Write your notes here…" style="flex:1; min-width:220px;">
        <button id="saveNote" class="btn" type="button">Save Note</button>
      </div>
      <ul id="notesList" class="stack" style="--gap:6px; margin:0; padding-left:18px;"></ul>
    </section>
  </main>

  <%- include('./partials/footer') %>

  <!-- EPUB.js for .epub rendering -->
  <script defer src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>

  <script>
  (async function () {
    const provider = "<%= provider %>";
    const id = "<%= id %>";
    const KEY_POS   = `bl:pos:${provider}:${id}`;
    const KEY_NOTES = `bl:notes:${provider}:${id}`;

    const titleEl = document.getElementById('title');
    const mount   = document.getElementById('reader');
    const fallback= document.getElementById('fallback');

    const btnBookmark = document.getElementById('btnBookmark');
    const btnListen   = document.getElementById('btnListen');
    const btnNotes    = document.getElementById('btnNotes');

    const noteInput = document.getElementById('noteInput');
    const saveNote  = document.getElementById('saveNote');
    const notesList = document.getElementById('notesList');

    // -------------- Supabase helpers (silent no-ops if not configured) --------------
    async function getSupabaseUser(){
      try {
        const sb = window.supabaseClient; if (!sb) return null;
        const { data: { user } } = await sb.auth.getUser();
        return user || null;
      } catch (_) { return null; }
    }

    async function fetchCloudPosition(){
      try {
        const sb = window.supabaseClient; if (!sb) return null;
        const user = await getSupabaseUser(); if (!user) return null;

        const { data, error } = await sb
          .from('reading_positions')
          .select('pos_type,cfi,scroll,updated_at')
          .eq('user_id', user.id)
          .eq('provider', provider)
          .eq('book_id', id)
          .order('updated_at', { ascending: false })
          .limit(1);

        if (error || !data || !data.length) return null;
        return data[0];
      } catch (_) { return null; }
    }

    async function saveCloudPosition(kind, value){
      try {
        const sb = window.supabaseClient; if (!sb) return;
        const user = await getSupabaseUser(); if (!user) return;

        const payload = {
          user_id: user.id,
          provider,
          book_id: id,
          pos_type: kind,
          cfi:   (kind === 'cfi'   ? value : null),
          scroll:(kind === 'scroll'? value : null),
          updated_at: new Date().toISOString()
        };
        await sb.from('reading_positions')
                .upsert(payload, { onConflict: 'user_id,provider,book_id' });
      } catch (_) { /* ignore cloud failure */ }
    }

    // -------------- Fetch book payload --------------
    fetch(`/api/book?provider=${encodeURIComponent(provider)}&id=${encodeURIComponent(id)}`)
      .then(r => r.json())
      .then(data => initReader(data))
      .catch(() => showFallback('Network error'));

    function showFallback(msg){
      fallback.textContent = msg || 'Loading book...';
      fallback.style.display = 'block';
      mount.style.display = 'none';
    }

    async function initReader(data){
      titleEl.textContent = [data?.title, data?.author].filter(Boolean).join(' — ') || 'Book';

      // -------------------- EPUB flow --------------------
      if (data?.type === 'epub' && data?.epubUrl){
        try {
          const book = ePub(data.epubUrl);
          const rendition = book.renderTo(mount, { width: "100%", height: "75vh", spread: "always" });

          // Prefer cloud if newer; otherwise local; then default start
          const localSaved = getSavedPos();
          let initialCFI = (localSaved && localSaved.type === 'cfi') ? localSaved.cfi : null;

          try {
            const cloud = await fetchCloudPosition();
            if (cloud && cloud.pos_type === 'cfi' && cloud.cfi) {
              // Compare timestamps if we have them both
              const localTs = localSaved?.ts || 0;
              const cloudTs = cloud?.updated_at ? Date.parse(cloud.updated_at) : 0;
              if (cloudTs && cloudTs >= localTs) initialCFI = cloud.cfi;
            }
          } catch (_) { /* ignore */ }

          if (initialCFI) await rendition.display(initialCFI);
          else await rendition.display();

          rendition.on('relocated', loc => {
            const cfi = loc?.start?.cfi;
            if (cfi){
              localStorage.setItem(KEY_POS, JSON.stringify({ type:'cfi', cfi, ts:Date.now() }));
              // Cloud (best-effort)
              saveCloudPosition('cfi', cfi);
            }
          });

          btnBookmark.addEventListener('click', async () => {
            const cfi = rendition.currentLocation()?.start?.cfi;
            if (cfi){
              localStorage.setItem(KEY_POS, JSON.stringify({ type:'cfi', cfi, ts:Date.now() }));
              saveCloudPosition('cfi', cfi);
              flash('Bookmark saved');
            }
          });
        } catch(e){ showFallback('Unable to render EPUB.'); }
        return;
      }

      // -------------------- HTML / Text flow --------------------
      mount.style.padding = '16px';
      if (data?.type === 'text'){
        mount.innerHTML = `<pre style="white-space:pre-wrap;word-wrap:break-word;">${escapeHtml(data.content||'')}</pre>`;
      } else if (data?.type === 'html'){
        mount.innerHTML = data.content || '<p>Not available.</p>';
      } else {
        showFallback('Book not available.');
        return;
      }

      // Scroll save/restore (local first, then try cloud)
      const localSaved = getSavedPos();
      if (localSaved && localSaved.type === 'scroll' && typeof localSaved.y === 'number') {
        mount.scrollTop = localSaved.y;
      }
      try {
        const cloud = await fetchCloudPosition();
        if (cloud && cloud.pos_type === 'scroll' && Number.isFinite(cloud.scroll)){
          const localTs = localSaved?.ts || 0;
          const cloudTs = cloud?.updated_at ? Date.parse(cloud.updated_at) : 0;
          if (cloudTs && cloudTs >= localTs) mount.scrollTop = cloud.scroll;
        }
      } catch (_) {}

      mount.addEventListener('scroll', throttle(() => {
        const y = mount.scrollTop|0;
        localStorage.setItem(KEY_POS, JSON.stringify({ type:'scroll', y, ts:Date.now() }));
        saveCloudPosition('scroll', y);
      }, 400));
    }

    function getSavedPos(){
      try { return JSON.parse(localStorage.getItem(KEY_POS)||'null'); }
      catch { return null; }
    }

    // -------------------- Notes (local only) --------------------
    function loadNotes(){ try { return JSON.parse(localStorage.getItem(KEY_NOTES)||'[]'); } catch { return []; } }
    function saveNotes(n){ localStorage.setItem(KEY_NOTES, JSON.stringify(n)); }
    function renderNotes(){
      const arr = loadNotes();
      notesList.innerHTML = arr.length ? '' : '<li style="opacity:.75;">No notes yet.</li>';
      arr.forEach((n, i) => {
        const li = document.createElement('li');
        li.innerHTML = `<span>${escapeHtml(n.text)}</span> <button class="btn" data-del="${i}" style="padding:2px 8px;margin-left:8px;">Delete</button>`;
        notesList.appendChild(li);
      });
    }
    saveNote.addEventListener('click', () => {
      const val = (noteInput.value||'').trim(); if (!val) return;
      const arr = loadNotes(); arr.push({ text: val, ts: Date.now() }); saveNotes(arr); noteInput.value=''; renderNotes(); flash('Note saved');
    });
    notesList.addEventListener('click', e => {
      const btn = e.target.closest('button[data-del]'); if (!btn) return;
      const idx = +btn.getAttribute('data-del'); const arr = loadNotes();
      if (idx>=0 && idx < arr.length){ arr.splice(idx,1); saveNotes(arr); renderNotes(); }
    });
    renderNotes();

    // -------------------- Listen (simple TTS) --------------------
    let speaking=false, paused=false, utter=null;
    btnListen.addEventListener('click', () => {
      if (!('speechSynthesis' in window)) return flash('Text-to-speech not supported.');
      if (speaking){ paused ? speechSynthesis.resume() : speechSynthesis.pause(); paused = !paused; btnListen.textContent = paused ? '⏸ Paused' : '🔊 Listen'; return; }
      const text = mount.textContent?.trim(); if (!text) return flash('Load content first.');
      speechSynthesis.cancel(); utter = new SpeechSynthesisUtterance(text); utter.rate=1;
      utter.onstart = ()=>{ speaking=true; btnListen.textContent='⏸ Paused'; };
      utter.onend   = ()=>{ speaking=false; paused=false; btnListen.textContent='🔊 Listen'; };
      utter.onerror = ()=>{ speaking=false; paused=false; btnListen.textContent='🔊 Listen'; };
      speechSynthesis.speak(utter);
    });

    // -------------------- utils --------------------
    function flash(msg){
      const el=document.createElement('div');
      el.textContent=msg;
      Object.assign(el.style,{
        position:'fixed',right:'16px',bottom:'16px',
        padding:'10px 12px',borderRadius:'12px',
        background:'rgba(0,0,0,.75)',color:'#fff',zIndex:9999,
        boxShadow:'0 6px 20px rgba(0,0,0,.25)'
      });
      document.body.appendChild(el);
      setTimeout(()=>el.remove(),1500);
    }
    function escapeHtml(s){return String(s).replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));}
    function throttle(fn, wait){ let t=0; return function(){ const n=Date.now(); if(n-t>wait){ t=n; fn.apply(this,arguments);} }; }
  })();
  </script>
</body>
</html>
