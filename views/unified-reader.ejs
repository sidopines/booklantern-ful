<!DOCTYPE html>
<html lang="en">
<head>
  <%- include('./partials/head.ejs', {
    pageTitle: (typeof pageTitle !== 'undefined' ? pageTitle : 'Reader'),
    pageDescription: (typeof pageDescription !== 'undefined' ? pageDescription : 'Distraction-free reading')
  }) %>
  <style>
    :root { --ink:#0f172a; --muted:#64748b; --line:#e2e8f0; --brand:#111; --bg:#ffffff; }
    html,body { margin:0; padding:0; height:100%; background:#fff; color:var(--ink); font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .topbar {
      position: sticky; top: 0; z-index: 20;
      display: flex; align-items: center; gap: 12px;
      height: 56px; padding: 0 12px; border-bottom: 1px solid var(--line); background: #fff;
    }
    .tb-btn{
      display:inline-flex; align-items:center; justify-content:center;
      height:36px; padding:0 12px; border:1px solid var(--line); border-radius:10px;
      background:#fff; cursor:pointer; font-weight:600;
    }
    .tb-meta{ flex:1; min-width:0; }
    .tb-title{ font-size:14px; font-weight:700; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .tb-author{ font-size:12px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .tb-actions{ display:flex; gap:8px; align-items:center; }

    /* Reader areas */
    #epub-viewer, #html-viewer { height: calc(100vh - 56px); }
    #epub-viewer{ overflow:hidden; }
    #html-viewer{
      overflow:auto;
      padding: 32px 20px 60px;
      max-width: 780px; margin: 0 auto;
      line-height: 1.6;
    }
    #html-viewer h1, #html-viewer h2, #html-viewer h3 { line-height:1.2; }
    #status{ position: fixed; bottom: 12px; left: 12px; font-size:12px; color: var(--muted); background:#fff; border:1px solid var(--line); border-radius:8px; padding:4px 8px; }

    @media (max-width: 700px){
      #html-viewer{ padding: 22px 14px 72px; }
      .tb-title{ max-width: 50vw; }
    }
  </style>
</head>
<body>
  <%- include('./partials/navbar.ejs') %>

  <div class="topbar">
    <button class="tb-btn" id="backBtn" aria-label="Go back">← Back</button>
    <div class="tb-meta">
      <div class="tb-title" id="titleEl"></div>
      <div class="tb-author" id="authorEl"></div>
    </div>
    <div class="tb-actions">
      <button class="tb-btn" id="listenBtn" aria-label="Listen">▶ Listen</button>
    </div>
  </div>

  <div id="epub-viewer" hidden></div>
  <div id="html-viewer" hidden></div>
  <div id="status" aria-live="polite"></div>

  <script>
    // Pass server data safely
    window.__BOOK__ = <%- JSON.stringify({
      gid: (typeof gid !== 'undefined' ? gid : ''),
      book: (typeof book !== 'undefined' ? book : { title:'', creator:'' }),
      htmlTitle: (typeof htmlTitle !== 'undefined' ? htmlTitle : ''),
      htmlAuthor: (typeof htmlAuthor !== 'undefined' ? htmlAuthor : ''),
      htmlFetchUrl: (typeof htmlFetchUrl !== 'undefined' ? htmlFetchUrl : '')
    }) %>;
  </script>

  <!-- ePub.js (only used if gid is present) -->
  <script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>
  <script>
    (function(){
      const S = window.__BOOK__ || {};
      const titleEl = document.getElementById('titleEl');
      const authorEl = document.getElementById('authorEl');
      const listenBtn = document.getElementById('listenBtn');
      const backBtn = document.getElementById('backBtn');
      const statusEl = document.getElementById('status');
      const epubEl = document.getElementById('epub-viewer');
      const htmlEl = document.getElementById('html-viewer');

      function setStatus(msg){ statusEl.textContent = msg || ''; }
      function escapeHTML(s){ return String(s||'').replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

      backBtn.addEventListener('click', () => {
        if (history.length > 1) history.back(); else window.location.href = '/read';
      });

      // Render header
      const hdrTitle = S.book?.title || S.htmlTitle || '';
      const hdrAuthor = S.book?.creator || S.htmlAuthor || '';
      titleEl.textContent = hdrTitle || 'Reader';
      authorEl.textContent = hdrAuthor || '';

      /* =========================
       * EPUB MODE (Gutenberg)
       * =======================*/
      if (S.gid) {
        const epubUrl = `/proxy/gutenberg-epub/${encodeURIComponent(S.gid)}`;
        epubEl.hidden = false;
        setStatus('Loading ePub…');

        try {
          const book = ePub(epubUrl);
          const rendition = book.renderTo('epub-viewer', { width: '100%', height: '100%' });
          rendition.display();

          // Keyboard left/right
          document.addEventListener('keydown', (e)=>{
            if (e.key === 'ArrowRight') rendition.next();
            else if (e.key === 'ArrowLeft') rendition.prev();
          });

          book.loaded.metadata.then(meta => {
            if (!hdrTitle && meta?.title) titleEl.textContent = meta.title;
            if (!hdrAuthor && meta?.creator) authorEl.textContent = meta.creator;
          });

          rendition.on('rendered', () => setStatus(''));
        } catch (err) {
          console.error('EPUB load failed, falling back to text:', err);
          fallbackToGutenbergText(S.gid);
        }

        // Listen (TTS) for EPUB: read current selection or page text
        listenBtn.addEventListener('click', async () => {
          try {
            const sel = window.getSelection()?.toString();
            if (sel) return speak(sel);
            // Pull visible text from iframe
            const ifr = epubEl.querySelector('iframe');
            const doc = ifr && ifr.contentDocument;
            const txt = doc ? doc.body.innerText : '';
            if (txt) speak(txt);
          } catch {}
        });

        return; // done
      }

      /* =========================
       * HTML MODE (Wikisource / other HTML)
       * =======================*/
      if (S.htmlFetchUrl) {
        htmlEl.hidden = false;
        setStatus('Loading text…');
        fetch(S.htmlFetchUrl, { credentials: 'same-origin' })
          .then(r => r.text())
          .then(html => {
            htmlEl.innerHTML = html;
            setStatus('');
          })
          .catch(err => {
            console.error('HTML fetch failed:', err);
            htmlEl.innerHTML = '<p class="hint">Could not load this text.</p>';
            setStatus('');
          });

        listenBtn.addEventListener('click', () => {
          speak(htmlEl.innerText || '');
        });
        return;
      }

      // If neither mode matched, show a friendly message
      setStatus('This item is not available.');

      /* =========================
       * Helpers
       * =======================*/
      function fallbackToGutenbergText(gid){
        epubEl.hidden = true;
        htmlEl.hidden = false;
        setStatus('Loading text…');
        fetch(`/read/gutenberg/${encodeURIComponent(gid)}/text`, { credentials: 'same-origin' })
          .then(r => r.json())
          .then(data => {
            const type = (data && data.type) || '';
            const content = (data && data.content) || '';
            if (!content) throw new Error('no content');
            if (type === 'html') {
              htmlEl.innerHTML = content;
            } else {
              htmlEl.textContent = content;
            }
            setStatus('');
          })
          .catch(err => {
            console.error('Gutenberg text fallback failed:', err);
            htmlEl.innerHTML = '<p class="hint">Could not load this book.</p>';
            setStatus('');
          });

        listenBtn.addEventListener('click', () => {
          speak(htmlEl.innerText || '');
        });
      }

      function speak(text){
        if (!text) return;
        try {
          window.speechSynthesis.cancel();
          const u = new SpeechSynthesisUtterance(text.slice(0, 5000)); // cap chunk
          u.rate = 1.0;
          u.pitch = 1.0;
          window.speechSynthesis.speak(u);
        } catch (e) { console.error('TTS failed', e); }
      }
    })();
  </script>
</body>
</html>
