<!-- views/unified-reader.ejs -->
<% if (typeof title === 'undefined') { var title = ''; } %>
<% if (typeof author === 'undefined') { var author = ''; } %>
<% if (typeof provider === 'undefined') { var provider = ''; } %>
<% if (typeof epubUrl === 'undefined') { var epubUrl = ''; } %>
<% if (typeof backHref === 'undefined') { var backHref = '/read'; } %>
<% 
  // Safe mode
  var safeMode;
  if (typeof mode === 'string') {
    safeMode = mode;
  } else if (typeof format === 'string' && format === 'epub') {
    safeMode = 'epub';
  } else {
    safeMode = 'iframe';
  }

  // Safe text fields
  var safeTitle  = (typeof title  === 'string' && title)  ? title  : 'Book';
  var safeAuthor = (typeof author === 'string' && author) ? author : '';
  var safeSource = (typeof source === 'string' && source) ? source : '';
%>
<!doctype html>
<html lang="en">
<head>
  <%- include('./partials/head.ejs', {
    pageTitle: safeTitle || 'Read ‚Ä¢ BookLantern',
    pageDescription: 'Reading ' + (safeTitle || 'book') + ' in BookLantern\'s unified reader'
  }) %>
  <link rel="preload" href="/public/js/reader.js" as="script"/>
  <style>
    #epub-root { min-height: 80vh; background:#111; }
    .reader-header { display:flex; align-items:center; gap:.75rem; padding:.75rem 0; }
    .reader-title { font-weight:600; }
    .reader-source { opacity:.7; font-size:0.9rem; }
    .reader-back { text-decoration:none; padding:0.5rem 1rem; background:#333; color:#fff; border-radius:6px; cursor:pointer; border:none; }
    .reader-back:hover { background:#444; }
    .reader-error { color:#dc2626; padding:2rem; text-align:center; }
  </style>
</head>
<body data-page="reader">
  <!-- Tiny Assistant Animation -->
  <div class="reader-assistant" id="reader-assistant" aria-hidden="true"></div>

  <header class="reader-topbar">
    <button class="reader-back" onclick="location.href='<%= (typeof backHref === 'string') ? backHref : '/read' %>'" tabindex="0" aria-label="Go back to previous page">
      <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
      </svg>
      Back
    </button>
    <div class="reader-title">
      <%= safeTitle %><% if (safeAuthor) { %> ‚Äî <%= safeAuthor %><% } %>
    </div>
    <div class="reader-source"><%= safeSource %></div>

    <!-- Admin test button -->
    <% if (typeof user !== 'undefined' && user && user.isAdmin && safeMode === 'epub') { %>
      <button class="btn small" onclick="testEpubUrl()" title="Test EPUB URL (Admin only)">üîß Test</button>
    <% } %>
    
    <!-- Debug Gutenberg link -->
    <% if (typeof user !== 'undefined' && user && user.isAdmin && typeof gid === 'string' && gid) { %>
      <a href="/proxy/gutenberg-epub/<%= gid %>?debug=1" target="_blank" class="btn small" title="Debug Gutenberg (Admin only)">üêõ Debug</a>
    <% } %>

    <!-- TTS controls -->
    <div class="tts-controls">
      <button id="ttsPlay" class="btn primary" title="Play/Pause (Space)">‚ñ∂ Play</button>
      <button id="ttsStop" class="btn" title="Stop (Esc)">‚èπ Stop</button>
      <button id="ttsPrev" class="btn" title="Previous sentence (‚Üê)">‚èÆ Prev</button>
      <button id="ttsNext" class="btn" title="Next sentence (‚Üí)">‚è≠ Next</button>
      <button id="ttsSel" class="btn" title="Read selection (S)">üìñ Selection</button>
      
      <label>Voice <select id="voiceSelect"></select></label>
      <label>Rate <input id="rate" type="range" min="0.5" max="1.75" step="0.1" value="1" class="slider"></label>
      <label>Vol <input id="vol" type="range" min="0" max="1" step="0.05" value="0.9" class="slider"></label>
      <span id="ttsStatus" class="tts-status">ready</span>
    </div>
  </header>

  <main class="page">
    <div id="status" class="muted small">loading‚Ä¶</div>
    <section class="pane">
      <div id="viewer" style="height: calc(100vh - 140px); width: 100%;"></div>
      <!-- Navigation chevrons -->
      <button class="nav-chevron prev" onclick="navigatePrev()" title="Previous page (‚Üê)">‚Äπ</button>
      <button class="nav-chevron next" onclick="navigateNext()" title="Next page (‚Üí)">‚Ä∫</button>
    </section>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>
  <script defer src="/public/js/reader.js<%= buildId ? `?v=${buildId}` : '' %>"></script>
  <script>
    const MODE = <%- JSON.stringify(mode||'') %>;
    const EPUB_URL = <%- JSON.stringify(typeof epubUrl==='string'?epubUrl:'') %>;
    const HTML_URL = <%- JSON.stringify(typeof htmlUrl==='string'?htmlUrl:'') %>;
    const PDF_URL = <%- JSON.stringify(typeof pdfUrl==='string'?pdfUrl:'') %>;

    const statusEl = document.getElementById('status');
    let book, rendition;
    
    function setStatus(s){ if (statusEl) statusEl.textContent = s; }
    
    // Navigation functions
    function navigatePrev() {
      if (rendition && rendition.prev) {
        rendition.prev();
      }
    }

    function navigateNext() {
      if (rendition && rendition.next) {
        rendition.next();
      }
    }
    
    // Initialize EPUB reader
    (function () {
      var url = "<%= typeof epubUrl !== 'undefined' && epubUrl ? epubUrl : '' %>";
      if (!url) { console.error('No epubUrl'); return; }
      var proxied = '/proxy?u=' + encodeURIComponent(url);
      try {
        setStatus('loading‚Ä¶');
        book = ePub(proxied);
        rendition = book.renderTo('viewer', { width: '100%', height: '100%' });
        rendition.display().then(() => {
          setStatus('ready');
        }).catch((e) => {
          console.error('epub render failed', e);
          setStatus('error');
        });
      } catch (e) { 
        console.error('epub init failed', e); 
        setStatus('error');
      }
    })();
    const GID = <%- JSON.stringify(typeof gid==='string'?gid:'') %>;
    const IA_ID = <%- JSON.stringify(typeof iaId==='string'?iaId:'') %>;

    const statusEl = document.getElementById('status');
    const bookBox = document.getElementById('bookBox');
    let book, rendition;
    
    // localStorage keys
    const STORAGE_KEYS = {
      THEME: 'booklantern_theme',
      FONT_SIZE: 'booklantern_font_size',
      TTS_RATE: 'booklantern_tts_rate',
      TTS_VOLUME: 'booklantern_tts_volume',
      TTS_VOICE: 'booklantern_tts_voice'
    };
    
    function setStatus(s){ statusEl.textContent = s; }

    // Load user preferences from localStorage
    function loadPreferences() {
      try {
        const theme = localStorage.getItem(STORAGE_KEYS.THEME) || 'light';
        const fontSize = localStorage.getItem(STORAGE_KEYS.FONT_SIZE) || '16px';
        const ttsRate = localStorage.getItem(STORAGE_KEYS.TTS_RATE) || '1';
        const ttsVolume = localStorage.getItem(STORAGE_KEYS.TTS_VOLUME) || '0.9';
        const ttsVoice = localStorage.getItem(STORAGE_KEYS.TTS_VOICE) || '';
        
        // Apply theme
        document.body.className = theme === 'dark' ? 'dark' : '';
        
        // Apply font size
        document.documentElement.style.fontSize = fontSize;
        
        // Apply TTS settings
        const rateEl = document.getElementById('rate');
        const volEl = document.getElementById('vol');
        const voiceSelect = document.getElementById('voiceSelect');
        
        if (rateEl) rateEl.value = ttsRate;
        if (volEl) volEl.value = ttsVolume;
        if (voiceSelect) voiceSelect.value = ttsVoice;
        
        return { theme, fontSize, ttsRate, ttsVolume, ttsVoice };
      } catch (e) {
        console.warn('Failed to load preferences:', e);
        return {};
      }
    }

    // Save user preferences to localStorage
    function savePreferences(key, value) {
      try {
        localStorage.setItem(key, value);
      } catch (e) {
        console.warn('Failed to save preference:', e);
      }
    }

    async function loadHTML(url) {
      try {
        setStatus('loading‚Ä¶');
        const r = await fetch(url, { credentials:'same-origin' });
        if (!r.ok) throw new Error('fetch failed');
        const html = await r.text();
        bookBox.innerHTML = html; // fragment from server
        hideLoading();
        setStatus('ready');
      } catch (e) {
        bookBox.innerHTML = '<div class="error-message">Could not load content.<br><button class="btn" onclick="location.reload()">Retry</button></div>';
        setStatus('error');
      }
    }

    async function loadEPUB() {
      try {
        setStatus('loading‚Ä¶');
        
        // For Gutenberg items, poll health endpoint until cached
        if (EPUB_URL.includes('/proxy/gutenberg-epub/')) {
          const gid = EPUB_URL.match(/\/proxy\/gutenberg-epub\/(\d+)/)?.[1];
          if (gid) {
            // Show spinner with progress message
            showProgressIndicator('Loading book...', 'Finding best EPUB source...');
            await pollGutenbergHealth(gid);
          }
        }
        
        // Step 1: Fetch EPUB as blob
        showProgressIndicator('Loading book...', 'Downloading EPUB file...');
        const r = await fetch(EPUB_URL, { cache: 'no-store' });
        if (!r.ok) {
          throw new Error(`HTTP ${r.status}: ${r.statusText}`);
        }
        
        // Step 2: Get blob and validate
        showProgressIndicator('Loading book...', 'Processing EPUB file...');
        const blob = await r.blob();
        if (blob.type !== 'application/epub+zip' && blob.size < 80 * 1024) {
          throw new Error('Invalid EPUB file (too small or wrong type)');
        }
        
        // Step 3: Create blob URL and load with EPUB.js
        const blobUrl = URL.createObjectURL(blob);
        book = ePub(blobUrl);
        rendition = book.renderTo('bookBox', { 
          flow: "paginated", 
          width: "100%", 
          height: "100%" 
        });
        
        // Step 4: Display with loading indicator (no timeout)
        const displayPromise = rendition.display();
        
        // Show loading indicator
        bookBox.innerHTML = '<div class="muted" style="display:flex;align-items:center;justify-content:center;height:100%;flex-direction:column;gap:1rem"><div>Loading book...</div><div style="font-size:0.9rem;color:#999">large books may take ~1‚Äì2 minutes on first open</div></div>';
        
        await displayPromise;
        
        // Success - hide spinner and show nav buttons
        setStatus('ready');
        
        // Initialize TTS after successful display
        initializeTTS();
        
      } catch (e) {
        console.error('EPUB load error:', e);
        showEPUBError(e.message);
        setStatus('error');
      }
    }

    async function loadIA(iaId) {
      try {
        setStatus('loading‚Ä¶');
        bookBox.innerHTML = '<div class="muted" style="display:flex;align-items:center;justify-content:center;height:100%">Loading Internet Archive book‚Ä¶</div>';
        
        // Create iframe for Internet Archive bookreader embed
        const iframe = document.createElement('iframe');
        iframe.src = `https://archive.org/embed/${iaId}?ui=embed#mode/1up`;
        iframe.style.width = '100%';
        iframe.style.height = '100%';
        iframe.style.border = 'none';
        iframe.style.borderRadius = '12px';
        iframe.title = 'Internet Archive Book Reader';
        
        // Clear loading message and add iframe
        bookBox.innerHTML = '';
        bookBox.appendChild(iframe);
        
        setStatus('ready');
        
      } catch (e) {
        console.error('IA load error:', e);
        bookBox.innerHTML = '<div class="error-message">Could not load Internet Archive book.<br><button class="btn" onclick="location.reload()">Retry</button></div>';
        setStatus('error');
      }
    }

    async function loadPDF(pdfUrl) {
      try {
        setStatus('loading‚Ä¶');
        bookBox.innerHTML = '<div class="muted" style="display:flex;align-items:center;justify-content:center;height:100%">Loading PDF‚Ä¶</div>';
        
        // Create iframe for PDF viewer
        const iframe = document.createElement('iframe');
        iframe.src = pdfUrl;
        iframe.style.width = '100%';
        iframe.style.height = '100%';
        iframe.style.border = 'none';
        iframe.style.borderRadius = '12px';
        iframe.title = 'PDF Viewer';
        
        // Clear loading message and add iframe
        bookBox.innerHTML = '';
        bookBox.appendChild(iframe);
        
        setStatus('ready');
        
      } catch (e) {
        console.error('PDF load error:', e);
        bookBox.innerHTML = '<div class="error-message">Could not load PDF.<br><button class="btn" onclick="location.reload()">Retry</button></div>';
        setStatus('error');
      }
    }

    function showEPUBError(message) {
      const debugLink = <% if (typeof user !== 'undefined' && user && user.isAdmin) { %>true<% } else { %>false<% } %>;
      const errorHtml = `
        <div class="error-message">
          <h3>Could not load EPUB</h3>
          <p>${message}</p>
          <div class="error-url">Failed URL: ${EPUB_URL}</div>
          <button class="btn primary" onclick="loadEPUB()">Retry</button>
          <button class="btn" onclick="openSource()">Open source</button>
          <button class="btn" onclick="tryNoImages()">Try no-images version</button>
          ${debugLink ? `<br><a href="${EPUB_URL}?debug=1" target="_blank" class="btn small" style="margin-top:0.5rem;font-size:0.8rem;">üîß Debug (Admin)</a>` : ''}
        </div>
      `;
      bookBox.innerHTML = errorHtml;
    }

    function openSource() {
      window.open(EPUB_URL, '_blank');
    }

    function tryNoImages() {
      if (MODE === 'epub' && GID) {
        // For Gutenberg EPUBs, reload with no-images parameter
        const currentUrl = new URL(window.location.href);
        currentUrl.searchParams.set('alt', 'noimages');
        window.location.href = currentUrl.toString();
      } else if (EPUB_URL) {
        // For other EPUBs, try adding the parameter to the proxy URL
        const newUrl = EPUB_URL.includes('?') ? `${EPUB_URL}&alt=noimages` : `${EPUB_URL}?alt=noimages`;
        if (typeof iframe !== 'undefined' && iframe.src) {
          iframe.src = newUrl;
        } else {
          location.reload();
        }
      }
    }

    function showProgressIndicator(mainMessage, subMessage) {
      bookBox.innerHTML = `
        <div class="muted" style="display:flex;align-items:center;justify-content:center;height:100%;flex-direction:column;gap:1rem">
          <div style="display:flex;align-items:center;gap:1rem">
            <div class="spinner" style="width:20px;height:20px;border:2px solid #ccc;border-top:2px solid #666;border-radius:50%;animation:spin 1s linear infinite"></div>
            <div>${mainMessage}</div>
          </div>
          <div style="font-size:0.9rem;color:#999">${subMessage}</div>
          <div style="font-size:0.8rem;color:#777">Loading may take up to 60 seconds for large books</div>
        </div>
        <style>
          @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }
        </style>
      `;
    }

    async function pollGutenbergHealth(gid) {
      const maxAttempts = 30; // 60 seconds max (30 * 2s intervals)
      let attempts = 0;
      
      while (attempts < maxAttempts) {
        try {
          const response = await fetch(`/health/gutenberg/${gid}`);
          if (response.ok) {
            const data = await response.json();
            if (data.cached && data.size > 0) {
              console.log(`[GUTENBERG] Health check: cached=true, size=${data.size}`);
              showProgressIndicator('Book ready!', 'Initializing reader...');
              return; // Success - file is cached
            }
          }
        } catch (e) {
          console.log('[GUTENBERG] Health check failed:', e.message);
        }
        
        attempts++;
        const remainingSeconds = (maxAttempts - attempts) * 2;
        if (attempts % 5 === 0) {
          showProgressIndicator('Loading book...', `Downloading EPUB... (~${remainingSeconds}s remaining)`);
        }
        await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds
      }
      
      console.log('[GUTENBERG] Health polling timed out after 60 seconds');
      throw new Error('Timeout: Book download took too long. Please try again.');
    }

    function downloadEPUB() {
      if (EPUB_URL) {
        const link = document.createElement('a');
        link.href = EPUB_URL;
        link.download = 'book.epub';
        link.click();
      }
    }

    // Navigation functions
    function navigatePrev() {
      if (rendition && rendition.prev) {
        rendition.prev();
      }
    }

    function navigateNext() {
      if (rendition && rendition.next) {
        rendition.next();
      }
    }

    // Admin test function
    async function testEpubUrl() {
      if (!EPUB_URL) return;
      
      try {
        console.log('[ADMIN] Testing EPUB URL:', EPUB_URL);
        const r = await fetch(EPUB_URL, { method: 'HEAD' });
        console.log('[ADMIN] Response status:', r.status);
        console.log('[ADMIN] Content-Type:', r.headers.get('content-type'));
        console.log('[ADMIN] Content-Length:', r.headers.get('content-length'));
        console.log('[ADMIN] Accept-Ranges:', r.headers.get('accept-ranges'));
        console.log('[ADMIN] All headers:', Object.fromEntries(r.headers.entries()));
      } catch (e) {
        console.error('[ADMIN] Test failed:', e.message);
      }
    }

    // Initialize TTS after EPUB loads
    function initializeTTS() {
      // TTS initialization will be called after successful EPUB display
      populateVoices();
    }

    // Load preferences on page load
    loadPreferences();

    if (MODE === 'html' && HTML_URL) loadHTML(HTML_URL);
    else if (MODE === 'epub' && EPUB_URL) loadEPUB();
    else if (MODE === 'ia' && IA_ID) loadIA(IA_ID);
    else if (MODE === 'pdf' && PDF_URL) loadPDF(PDF_URL);
    else { bookBox.innerHTML = '<div class="muted">No content.</div>'; setStatus('error'); }

    /* ---------- Enhanced TTS with Preferences ---------- */
    const playBtn = document.getElementById('ttsPlay');
    const stopBtn = document.getElementById('ttsStop');
    const prevBtn = document.getElementById('ttsPrev');
    const nextBtn = document.getElementById('ttsNext');
    const selBtn = document.getElementById('ttsSel');
    const voiceSelect = document.getElementById('voiceSelect');
    const rateEl = document.getElementById('rate');
    const volEl = document.getElementById('vol');
    const ttsStatus = document.getElementById('ttsStatus');
    
    let isPlaying = false;
    let currentUtterance = null;
    let sentences = [];
    let currentSentenceIndex = 0;

    // Populate voice select
    function populateVoices() {
      if (!('speechSynthesis' in window)) return;
      
      const voices = speechSynthesis.getVoices();
      voiceSelect.innerHTML = '';
      
      voices.forEach((voice, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.textContent = `${voice.name} (${voice.lang})`;
        voiceSelect.appendChild(option);
      });
      
      // Restore saved voice preference
      const savedVoice = localStorage.getItem(STORAGE_KEYS.TTS_VOICE);
      if (savedVoice && voiceSelect.querySelector(`option[value="${savedVoice}"]`)) {
        voiceSelect.value = savedVoice;
      }
    }

    // Initialize voices (will be called after EPUB loads)
    if ('speechSynthesis' in window) {
      speechSynthesis.onvoiceschanged = populateVoices;
    }

    // Save TTS preferences when changed
    rateEl.addEventListener('input', () => {
      savePreferences(STORAGE_KEYS.TTS_RATE, rateEl.value);
    });
    
    volEl.addEventListener('input', () => {
      savePreferences(STORAGE_KEYS.TTS_VOLUME, volEl.value);
    });
    
    voiceSelect.addEventListener('change', () => {
      savePreferences(STORAGE_KEYS.TTS_VOICE, voiceSelect.value);
    });

    function updateStatus(status) {
      ttsStatus.textContent = status;
      isPlaying = status === 'reading';
      playBtn.textContent = isPlaying ? '‚è∏ Pause' : '‚ñ∂ Play';
    }

    function getCurrentText() {
      // Try to get selected text first
      const selection = window.getSelection();
      if (selection && selection.toString().trim()) {
        return selection.toString().trim();
      }
      
      // For EPUB, try to get current page text
      if (rendition && rendition.currentLocation) {
        try {
          const location = rendition.currentLocation();
          if (location && location.start) {
            return book.locations.get(location.start).then(loc => {
              return loc.content || '';
            }).catch(() => {
              return bookBox.innerText.replace(/\s+/g, ' ').trim().slice(0, 8000);
            });
          }
        } catch (e) {
          console.log('Could not get EPUB location, using fallback');
        }
      }
      
      // Fallback to visible text
      return bookBox.innerText.replace(/\s+/g, ' ').trim().slice(0, 8000);
    }

    function splitIntoSentences(text) {
      return text.split(/[.!?]+/).filter(s => s.trim().length > 0);
    }

    function speak(text, options = {}) {
      if (!('speechSynthesis' in window)) return;
      
      // Cancel any ongoing speech
      window.speechSynthesis.cancel();
      
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.rate = parseFloat(rateEl.value || '1');
      utterance.volume = parseFloat(volEl.value || '0.9');
      
      if (voiceSelect.value) {
        const voices = speechSynthesis.getVoices();
        utterance.voice = voices[parseInt(voiceSelect.value)];
      }
      
      utterance.onstart = () => updateStatus('reading');
      utterance.onend = () => updateStatus('ready');
      utterance.onerror = () => updateStatus('error');
      
      currentUtterance = utterance;
      window.speechSynthesis.speak(utterance);
    }

    function speakCurrentPage() {
      const text = getCurrentText();
      if (typeof text === 'string') {
        sentences = splitIntoSentences(text);
        currentSentenceIndex = 0;
        if (sentences.length > 0) {
          speak(sentences[0]);
        }
      } else {
        // Handle promise from EPUB location
        text.then(t => {
          sentences = splitIntoSentences(t);
          currentSentenceIndex = 0;
          if (sentences.length > 0) {
            speak(sentences[0]);
          }
        });
      }
    }

    function speakNextSentence() {
      if (sentences.length === 0) {
        speakCurrentPage();
        return;
      }
      
      currentSentenceIndex = Math.min(currentSentenceIndex + 1, sentences.length - 1);
      if (sentences[currentSentenceIndex]) {
        speak(sentences[currentSentenceIndex]);
      }
    }

    function speakPrevSentence() {
      if (sentences.length === 0) {
        speakCurrentPage();
        return;
      }
      
      currentSentenceIndex = Math.max(currentSentenceIndex - 1, 0);
      if (sentences[currentSentenceIndex]) {
        speak(sentences[currentSentenceIndex]);
      }
    }

    function togglePlayPause() {
      if (isPlaying) {
        window.speechSynthesis.pause();
        updateStatus('paused');
      } else if (window.speechSynthesis.speaking) {
        window.speechSynthesis.resume();
        updateStatus('reading');
      } else {
        speakCurrentPage();
      }
    }

    // Event listeners
    playBtn.addEventListener('click', togglePlayPause);
    stopBtn.addEventListener('click', () => {
      window.speechSynthesis.cancel();
      updateStatus('ready');
    });
    prevBtn.addEventListener('click', speakPrevSentence);
    nextBtn.addEventListener('click', speakNextSentence);
    selBtn.addEventListener('click', () => {
      const selection = window.getSelection();
      if (selection && selection.toString().trim()) {
        speak(selection.toString().trim());
      }
    });

    // Enhanced keyboard shortcuts with page navigation
    document.addEventListener('keydown', (e) => {
      // Don't interfere with form inputs
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') return;
      
      let handled = false;
      
      switch(e.key) {
        case ' ':
          e.preventDefault();
          togglePlayPause();
          handled = true;
          break;
        case 'Escape':
          e.preventDefault();
          window.speechSynthesis.cancel();
          updateStatus('ready');
          handled = true;
          break;
        case 'ArrowLeft':
          if (e.ctrlKey || e.metaKey) {
            // Ctrl/Cmd + Left = Previous page
            e.preventDefault();
            navigatePrev();
            handled = true;
          } else {
            // Left arrow = Previous sentence
            e.preventDefault();
            speakPrevSentence();
            handled = true;
          }
          break;
        case 'ArrowRight':
          if (e.ctrlKey || e.metaKey) {
            // Ctrl/Cmd + Right = Next page
            e.preventDefault();
            navigateNext();
            handled = true;
          } else {
            // Right arrow = Next sentence
            e.preventDefault();
            speakNextSentence();
            handled = true;
          }
          break;
        case 's':
        case 'S':
          e.preventDefault();
          const selection = window.getSelection();
          if (selection && selection.toString().trim()) {
            speak(selection.toString().trim());
          }
          handled = true;
          break;
        case 'Home':
          // Go to beginning of book
          if (rendition && rendition.display) {
            e.preventDefault();
            rendition.display();
            handled = true;
          }
          break;
        case 'End':
          // Go to end of book
          if (book && book.locations) {
            e.preventDefault();
            book.locations.generate().then(() => {
              const total = book.locations.total;
              if (total > 0) {
                rendition.display(book.locations.get(total - 1));
              }
            });
            handled = true;
          }
          break;
      }
      
      // Prevent page scrolling for handled shortcuts
      if (handled) {
        e.stopPropagation();
      }
    });
  </script>
</body>
</html>
