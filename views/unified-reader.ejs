<!DOCTYPE html>
<html lang="en">
<head>
  <%- include('./partials/head.ejs', {
    pageTitle: (typeof pageTitle !== 'undefined' ? pageTitle : 'Reader'),
    pageDescription: (typeof pageDescription !== 'undefined' ? pageDescription : 'Distraction-free reading')
  }) %>
  <style>
    :root { --ink:#0f172a; --muted:#64748b; --line:#e2e8f0; --brand:#111; --bg:#ffffff; }
    html,body { margin:0; padding:0; height:100%; background:#fff; color:var(--ink); font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .topbar {
      position: sticky; top: 0; z-index: 20;
      display: flex; align-items: center; gap: 12px;
      height: 56px; padding: 0 12px; border-bottom: 1px solid var(--line); background: #fff;
    }
    .tb-btn{
      display:inline-flex; align-items:center; justify-content:center;
      height:36px; padding:0 12px; border:1px solid var(--line); border-radius:10px;
      background:#fff; cursor:pointer; font-weight:600;
    }
    .tb-meta{ flex:1; min-width:0; }
    .tb-title{ font-size:14px; font-weight:700; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .tb-author{ font-size:12px; color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .tb-actions{ display:flex; gap:8px; align-items:center; }

    #epub-viewer, #html-viewer { height: calc(100vh - 56px); }
    #epub-viewer{ overflow:hidden; }
    #html-viewer{
      overflow:auto;
      padding: 32px 20px 60px;
      max-width: 780px; margin: 0 auto;
      line-height: 1.6;
    }
    #html-viewer h1, #html-viewer h2, #html-viewer h3 { line-height:1.2; }
    #status{ position: fixed; bottom: 12px; left: 12px; font-size:12px; color: var(--muted); background:#fff; border:1px solid var(--line); border-radius:8px; padding:4px 8px; }

    @media (max-width: 700px){
      #html-viewer{ padding: 22px 14px 72px; }
      .tb-title{ max-width: 50vw; }
    }
  </style>
</head>
<body>
  <%- include('./partials/navbar.ejs') %>

  <div class="topbar">
    <button class="tb-btn" id="backBtn" aria-label="Go back">← Back</button>
    <div class="tb-meta">
      <div class="tb-title" id="titleEl"></div>
      <div class="tb-author" id="authorEl"></div>
    </div>
    <div class="tb-actions">
      <button class="tb-btn" id="listenBtn" aria-label="Listen">▶ Listen</button>
    </div>
  </div>

  <div id="epub-viewer" hidden></div>
  <div id="html-viewer" hidden></div>
  <div id="status" aria-live="polite"></div>

  <script>
    window.__BOOK__ = <%- JSON.stringify({
      gid: (typeof gid !== 'undefined' ? gid : ''),
      book: (typeof book !== 'undefined' ? book : { title:'', creator:'' }),
      htmlTitle: (typeof htmlTitle !== 'undefined' ? htmlTitle : ''),
      htmlAuthor: (typeof htmlAuthor !== 'undefined' ? htmlAuthor : ''),
      htmlFetchUrl: (typeof htmlFetchUrl !== 'undefined' ? htmlFetchUrl : '')
    }) %>;
  </script>

  <!-- Load ePub.js only if/when needed -->
  <script>
    (function(){
      const S = window.__BOOK__ || {};
      const titleEl = document.getElementById('titleEl');
      const authorEl = document.getElementById('authorEl');
      const listenBtn = document.getElementById('listenBtn');
      const backBtn = document.getElementById('backBtn');
      const statusEl = document.getElementById('status');
      const epubEl = document.getElementById('epub-viewer');
      const htmlEl = document.getElementById('html-viewer');

      function setStatus(msg){ statusEl.textContent = msg || ''; }
      backBtn.addEventListener('click', () => { if (history.length > 1) history.back(); else window.location.href = '/read'; });

      const hdrTitle = S.book?.title || S.htmlTitle || '';
      const hdrAuthor = S.book?.creator || S.htmlAuthor || '';
      titleEl.textContent = hdrTitle || 'Reader';
      authorEl.textContent = hdrAuthor || '';

      // EPUB MODE
      if (S.gid) {
        epubEl.hidden = false;
        setStatus('Loading ePub…');

        // Load epub.js first, then render
        const script = document.createElement('script');
        script.src = 'https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js';
        script.onload = () => startEpub();
        script.onerror = () => fallbackToGutenbergText(S.gid);
        document.head.appendChild(script);

        function startEpub(){
          try {
            const epubUrl = `/proxy/gutenberg-epub/${encodeURIComponent(S.gid)}`;
            const book = window.ePub(epubUrl);
            const rendition = book.renderTo('epub-viewer', { width: '100%', height: '100%' });
            let rendered = false;

            const watchdog = setTimeout(() => {
              if (!rendered) {
                console.warn('EPUB render timeout — falling back to text');
                fallbackToGutenbergText(S.gid);
              }
            }, 4000);

            rendition.display().then(() => {
              rendered = true;
              clearTimeout(watchdog);
              setStatus('');
            }).catch(() => {
              clearTimeout(watchdog);
              fallbackToGutenbergText(S.gid);
            });

            // Keyboard left/right
            document.addEventListener('keydown', (e)=>{
              if (e.key === 'ArrowRight') rendition.next();
              else if (e.key === 'ArrowLeft') rendition.prev();
            });

            book.loaded.metadata.then(meta => {
              if (!hdrTitle && meta?.title) titleEl.textContent = meta.title;
              if (!hdrAuthor && meta?.creator) authorEl.textContent = meta.creator;
            });

            listenBtn.addEventListener('click', async () => {
              try {
                const ifr = epubEl.querySelector('iframe');
                const doc = ifr && ifr.contentDocument;
                const txt = doc ? doc.body.innerText : '';
                if (txt) speak(txt);
              } catch {}
            });
          } catch (err) {
            console.error('EPUB init failed', err);
            fallbackToGutenbergText(S.gid);
          }
        }

        return;
      }

      // HTML MODE (Wikisource etc.)
      if (S.htmlFetchUrl) {
        htmlEl.hidden = false;
        setStatus('Loading text…');
        fetch(S.htmlFetchUrl, { credentials: 'same-origin' })
          .then(r => r.text())
          .then(html => { htmlEl.innerHTML = html; setStatus(''); })
          .catch(err => { console.error('HTML fetch failed:', err); htmlEl.innerHTML = '<p class="hint">Could not load this text.</p>'; setStatus(''); });

        listenBtn.addEventListener('click', () => speak(htmlEl.innerText || ''));
        return;
      }

      // Nothing matched
      setStatus('This item is not available.');

      function fallbackToGutenbergText(gid){
        epubEl.hidden = true;
        htmlEl.hidden = false;
        setStatus('Loading text…');
        fetch(`/read/gutenberg/${encodeURIComponent(gid)}/text`, { credentials: 'same-origin' })
          .then(r => r.json())
          .then(data => {
            const type = (data && data.type) || '';
            const content = (data && data.content) || '';
            if (!content) throw new Error('no content');
            if (type === 'html') htmlEl.innerHTML = content; else htmlEl.textContent = content;
            setStatus('');
          })
          .catch(err => { console.error('Gutenberg text fallback failed:', err); htmlEl.innerHTML = '<p class="hint">Could not load this book.</p>'; setStatus(''); });

        listenBtn.addEventListener('click', () => speak(htmlEl.innerText || ''));
      }

      function speak(text){
        if (!text) return;
        try {
          window.speechSynthesis.cancel();
          const u = new SpeechSynthesisUtterance(text.slice(0, 5000));
          u.rate = 1.0; u.pitch = 1.0;
          window.speechSynthesis.speak(u);
        } catch (e) { console.error('TTS failed', e); }
      }
    })();
  </script>
</body>
</html>
