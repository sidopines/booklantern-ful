<!-- views/unified-reader.ejs -->
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title><%= pageTitle || 'Read ‚Ä¢ BookLantern' %></title>
  <link rel="stylesheet" href="/css/site.css"/>
  <style>
    body{background:#fff;}
    
    /* Enhanced toolbar with backdrop filter and solid contrast */
    .topbar{
      position:sticky;top:0;z-index:100;
      background:rgba(255,255,255,0.95);backdrop-filter:blur(10px);
      display:flex;gap:.5rem;align-items:center;padding:.75rem;
      border-bottom:1px solid #e5e7eb;box-shadow:0 2px 8px rgba(0,0,0,0.1)
    }
    
    .page{max-width:1200px;margin:0 auto;padding:.5rem}
    .pane{min-height:80vh;display:flex;justify-content:center;align-items:flex-start;position:relative}
    
    /* Centered reader with proper dimensions */
    #bookBox{
      width:100%;max-width:1200px;height:80vh;
      border-radius:12px;border:1px solid #e5e7eb;
      box-shadow:0 4px 20px rgba(0,0,0,.08);background:#fff;
      padding:0;overflow:hidden;position:relative
    }
    
    /* Navigation chevrons - always visible */
    .nav-chevron{
      position:absolute;top:50%;transform:translateY(-50%);
      z-index:50;background:rgba(255,255,255,0.9);backdrop-filter:blur(8px);
      border:1px solid #e5e7eb;border-radius:50%;width:48px;height:48px;
      display:flex;align-items:center;justify-content:center;
      cursor:pointer;transition:all 0.2s;font-size:18px;font-weight:bold;
      box-shadow:0 2px 8px rgba(0,0,0,0.1)
    }
    .nav-chevron:hover{background:rgba(255,255,255,1);transform:translateY(-50%) scale(1.05)}
    .nav-chevron.prev{left:-24px}
    .nav-chevron.next{right:-24px}
    
    .muted{color:#777}
    .btn{padding:.4rem .6rem;border-radius:10px;border:1px solid #e5e7eb;background:#fff;color:#333;font-weight:600;cursor:pointer;transition:all 0.2s}
    .btn:hover{background:#f8f9fa;border-color:#d1d5db}
    .btn.primary{background:#4f46e5;color:#fff;border-color:#4f46e5}
    .btn.primary:hover{background:#4338ca;border-color:#4338ca}
    .btn.back{background:#dc2626;color:#fff;border-color:#dc2626;font-weight:700}
    .btn.back:hover{background:#b91c1c;border-color:#b91c1c}
    .small{font-size:.9rem}
    .grow{flex:1}
    .slider{vertical-align:middle}
    
    .tts-controls{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap}
    .tts-controls label{display:flex;align-items:center;gap:.25rem;color:#666;font-size:.85rem}
    .tts-controls select{padding:.2rem .4rem;border-radius:6px;border:1px solid #d1d5db;font-size:.85rem}
    .tts-status{color:#059669;font-size:.8rem;font-weight:600}
    
    /* Enhanced error message */
    .error-message{
      background:#fef2f2;border:1px solid #fecaca;color:#dc2626;
      padding:2rem;border-radius:12px;text-align:center;margin:2rem auto;
      max-width:500px;box-shadow:0 4px 12px rgba(220,38,38,0.1)
    }
    .error-message h3{margin:0 0 1rem 0;font-size:1.2rem}
    .error-message p{margin:0 0 1.5rem 0;color:#7f1d1d}
    .error-message .btn{margin:0.5rem;display:inline-block}
    .error-url{background:#fee2e2;padding:0.5rem;border-radius:6px;font-family:monospace;font-size:0.9rem;margin:1rem 0;word-break:break-all}
    
    .navigation{display:flex;gap:.5rem;margin-top:1rem}
    
    /* Theme support */
    body.dark{background:#1f2937;color:#f9fafb}
    body.dark .topbar{background:rgba(31,41,55,0.95);border-bottom-color:#374151}
    body.dark #bookBox{background:#374151;border-color:#4b5563}
    body.dark .nav-chevron{background:rgba(55,65,81,0.9);border-color:#4b5563;color:#f9fafb}
    body.dark .nav-chevron:hover{background:rgba(55,65,81,1)}
  </style>
  <% if (mode === 'epub') { %>
  <script src="https://unpkg.com/epubjs@0.3/dist/epub.min.js"></script>
  <% } %>
</head>
<body>
  <header class="topbar page">
    <button class="btn back" onclick="history.back()" tabindex="0" aria-label="Go back to previous page">&larr; Back</button>
    <div class="muted small"><%= title || 'Book' %><% if (typeof author === 'string' && author) { %> ‚Äî <%= author %><% } %></div>
    <div class="grow"></div>

    <!-- Admin test button -->
    <% if (typeof user !== 'undefined' && user && user.isAdmin && mode === 'epub') { %>
      <button class="btn small" onclick="testEpubUrl()" title="Test EPUB URL (Admin only)">üîß Test</button>
    <% } %>
    
    <!-- Debug Gutenberg link -->
    <% if (typeof user !== 'undefined' && user && user.isAdmin && typeof gid === 'string' && gid) { %>
      <a href="/proxy/gutenberg-epub/<%= gid %>?debug=1" target="_blank" class="btn small" title="Debug Gutenberg (Admin only)">üêõ Debug</a>
    <% } %>

    <!-- TTS controls -->
    <div class="tts-controls">
      <button id="ttsPlay" class="btn primary" title="Play/Pause (Space)">‚ñ∂ Play</button>
      <button id="ttsStop" class="btn" title="Stop (Esc)">‚èπ Stop</button>
      <button id="ttsPrev" class="btn" title="Previous sentence (‚Üê)">‚èÆ Prev</button>
      <button id="ttsNext" class="btn" title="Next sentence (‚Üí)">‚è≠ Next</button>
      <button id="ttsSel" class="btn" title="Read selection (S)">üìñ Selection</button>
      
      <label>Voice <select id="voiceSelect"></select></label>
      <label>Rate <input id="rate" type="range" min="0.5" max="1.75" step="0.1" value="1" class="slider"></label>
      <label>Vol <input id="vol" type="range" min="0" max="1" step="0.05" value="0.9" class="slider"></label>
      <span id="ttsStatus" class="tts-status">ready</span>
    </div>
  </header>

  <main class="page">
    <div id="status" class="muted small">loading‚Ä¶</div>
    <section class="pane">
      <div id="bookBox">
        <div class="muted" style="display:flex;align-items:center;justify-content:center;height:100%">Loading‚Ä¶</div>
      </div>
      <!-- Navigation chevrons -->
      <button class="nav-chevron prev" onclick="navigatePrev()" title="Previous page (‚Üê)">‚Äπ</button>
      <button class="nav-chevron next" onclick="navigateNext()" title="Next page (‚Üí)">‚Ä∫</button>
    </section>
  </main>

  <script>
    const MODE = <%- JSON.stringify(mode||'') %>;
    const EPUB_URL = <%- JSON.stringify(typeof epubUrl==='string'?epubUrl:'') %>;
    const HTML_URL = <%- JSON.stringify(typeof htmlUrl==='string'?htmlUrl:'') %>;
    const PDF_URL = <%- JSON.stringify(typeof pdfUrl==='string'?pdfUrl:'') %>;
    const GID = <%- JSON.stringify(typeof gid==='string'?gid:'') %>;
    const IA_ID = <%- JSON.stringify(typeof iaId==='string'?iaId:'') %>;

    const statusEl = document.getElementById('status');
    const bookBox = document.getElementById('bookBox');
    let book, rendition;
    
    // localStorage keys
    const STORAGE_KEYS = {
      THEME: 'booklantern_theme',
      FONT_SIZE: 'booklantern_font_size',
      TTS_RATE: 'booklantern_tts_rate',
      TTS_VOLUME: 'booklantern_tts_volume',
      TTS_VOICE: 'booklantern_tts_voice'
    };
    
    function setStatus(s){ statusEl.textContent = s; }

    // Load user preferences from localStorage
    function loadPreferences() {
      try {
        const theme = localStorage.getItem(STORAGE_KEYS.THEME) || 'light';
        const fontSize = localStorage.getItem(STORAGE_KEYS.FONT_SIZE) || '16px';
        const ttsRate = localStorage.getItem(STORAGE_KEYS.TTS_RATE) || '1';
        const ttsVolume = localStorage.getItem(STORAGE_KEYS.TTS_VOLUME) || '0.9';
        const ttsVoice = localStorage.getItem(STORAGE_KEYS.TTS_VOICE) || '';
        
        // Apply theme
        document.body.className = theme === 'dark' ? 'dark' : '';
        
        // Apply font size
        document.documentElement.style.fontSize = fontSize;
        
        // Apply TTS settings
        const rateEl = document.getElementById('rate');
        const volEl = document.getElementById('vol');
        const voiceSelect = document.getElementById('voiceSelect');
        
        if (rateEl) rateEl.value = ttsRate;
        if (volEl) volEl.value = ttsVolume;
        if (voiceSelect) voiceSelect.value = ttsVoice;
        
        return { theme, fontSize, ttsRate, ttsVolume, ttsVoice };
      } catch (e) {
        console.warn('Failed to load preferences:', e);
        return {};
      }
    }

    // Save user preferences to localStorage
    function savePreferences(key, value) {
      try {
        localStorage.setItem(key, value);
      } catch (e) {
        console.warn('Failed to save preference:', e);
      }
    }

    async function loadHTML(url) {
      try {
        setStatus('loading‚Ä¶');
        const r = await fetch(url, { credentials:'same-origin' });
        if (!r.ok) throw new Error('fetch failed');
        const html = await r.text();
        bookBox.innerHTML = html; // fragment from server
        setStatus('ready');
      } catch (e) {
        bookBox.innerHTML = '<div class="error-message">Could not load content.<br><button class="btn" onclick="location.reload()">Retry</button></div>';
        setStatus('error');
      }
    }

    async function loadEPUB() {
      try {
        setStatus('loading‚Ä¶');
        bookBox.innerHTML = '<div class="muted" style="display:flex;align-items:center;justify-content:center;height:100%">Loading EPUB‚Ä¶</div>';
        
        // Step 1: Fetch EPUB as blob
        const r = await fetch(EPUB_URL, { cache: 'no-store' });
        if (!r.ok) {
          throw new Error(`HTTP ${r.status}: ${r.statusText}`);
        }
        
        // Step 2: Get blob and validate
        const blob = await r.blob();
        if (blob.type !== 'application/epub+zip' && blob.size < 80 * 1024) {
          throw new Error('Invalid EPUB file (too small or wrong type)');
        }
        
        // Step 3: Create blob URL and load with EPUB.js
        const blobUrl = URL.createObjectURL(blob);
        book = ePub(blobUrl);
        rendition = book.renderTo('bookBox', { 
          flow: "paginated", 
          width: "100%", 
          height: "100%" 
        });
        
        // Step 4: Display with watchdog timer
        const displayPromise = rendition.display();
        const watchdogPromise = new Promise((_, reject) => {
          setTimeout(() => reject(new Error('Display timeout')), 12000);
        });
        
        await Promise.race([displayPromise, watchdogPromise]);
        
        // Success - hide spinner and show nav buttons
        setStatus('ready');
        
        // Initialize TTS after successful display
        initializeTTS();
        
      } catch (e) {
        console.error('EPUB load error:', e);
        showEPUBError(e.message);
        setStatus('error');
      }
    }

    async function loadIA(iaId) {
      try {
        setStatus('loading‚Ä¶');
        bookBox.innerHTML = '<div class="muted" style="display:flex;align-items:center;justify-content:center;height:100%">Loading Internet Archive book‚Ä¶</div>';
        
        // Create iframe for Internet Archive bookreader embed
        const iframe = document.createElement('iframe');
        iframe.src = `https://archive.org/embed/${iaId}?ui=embed#mode/1up`;
        iframe.style.width = '100%';
        iframe.style.height = '100%';
        iframe.style.border = 'none';
        iframe.style.borderRadius = '12px';
        iframe.title = 'Internet Archive Book Reader';
        
        // Clear loading message and add iframe
        bookBox.innerHTML = '';
        bookBox.appendChild(iframe);
        
        setStatus('ready');
        
      } catch (e) {
        console.error('IA load error:', e);
        bookBox.innerHTML = '<div class="error-message">Could not load Internet Archive book.<br><button class="btn" onclick="location.reload()">Retry</button></div>';
        setStatus('error');
      }
    }

    async function loadPDF(pdfUrl) {
      try {
        setStatus('loading‚Ä¶');
        bookBox.innerHTML = '<div class="muted" style="display:flex;align-items:center;justify-content:center;height:100%">Loading PDF‚Ä¶</div>';
        
        // Create iframe for PDF viewer
        const iframe = document.createElement('iframe');
        iframe.src = pdfUrl;
        iframe.style.width = '100%';
        iframe.style.height = '100%';
        iframe.style.border = 'none';
        iframe.style.borderRadius = '12px';
        iframe.title = 'PDF Viewer';
        
        // Clear loading message and add iframe
        bookBox.innerHTML = '';
        bookBox.appendChild(iframe);
        
        setStatus('ready');
        
      } catch (e) {
        console.error('PDF load error:', e);
        bookBox.innerHTML = '<div class="error-message">Could not load PDF.<br><button class="btn" onclick="location.reload()">Retry</button></div>';
        setStatus('error');
      }
    }

    function showEPUBError(message) {
      const debugLink = <% if (typeof user !== 'undefined' && user && user.isAdmin) { %>true<% } else { %>false<% } %>;
      const errorHtml = `
        <div class="error-message">
          <h3>Could not load EPUB</h3>
          <p>${message}</p>
          <div class="error-url">Failed URL: ${EPUB_URL}</div>
          <button class="btn primary" onclick="loadEPUB()">Retry</button>
          <button class="btn" onclick="openSource()">Open source</button>
          <button class="btn" onclick="tryNoImages()">Try no-images version</button>
          ${debugLink ? `<br><a href="${EPUB_URL}?debug=1" target="_blank" class="btn small" style="margin-top:0.5rem;font-size:0.8rem;">üîß Debug (Admin)</a>` : ''}
        </div>
      `;
      bookBox.innerHTML = errorHtml;
    }

    function openSource() {
      window.open(EPUB_URL, '_blank');
    }

    function tryNoImages() {
      if (MODE === 'epub' && GID) {
        // For Gutenberg EPUBs, reload with no-images parameter
        const currentUrl = new URL(window.location.href);
        currentUrl.searchParams.set('alt', 'noimages');
        window.location.href = currentUrl.toString();
      } else if (EPUB_URL) {
        // For other EPUBs, try adding the parameter to the proxy URL
        const newUrl = EPUB_URL.includes('?') ? `${EPUB_URL}&alt=noimages` : `${EPUB_URL}?alt=noimages`;
        if (typeof iframe !== 'undefined' && iframe.src) {
          iframe.src = newUrl;
        } else {
          location.reload();
        }
      }
    }

    function downloadEPUB() {
      if (EPUB_URL) {
        const link = document.createElement('a');
        link.href = EPUB_URL;
        link.download = 'book.epub';
        link.click();
      }
    }

    // Navigation functions
    function navigatePrev() {
      if (rendition && rendition.prev) {
        rendition.prev();
      }
    }

    function navigateNext() {
      if (rendition && rendition.next) {
        rendition.next();
      }
    }

    // Admin test function
    async function testEpubUrl() {
      if (!EPUB_URL) return;
      
      try {
        console.log('[ADMIN] Testing EPUB URL:', EPUB_URL);
        const r = await fetch(EPUB_URL, { method: 'HEAD' });
        console.log('[ADMIN] Response status:', r.status);
        console.log('[ADMIN] Content-Type:', r.headers.get('content-type'));
        console.log('[ADMIN] Content-Length:', r.headers.get('content-length'));
        console.log('[ADMIN] Accept-Ranges:', r.headers.get('accept-ranges'));
        console.log('[ADMIN] All headers:', Object.fromEntries(r.headers.entries()));
      } catch (e) {
        console.error('[ADMIN] Test failed:', e.message);
      }
    }

    // Initialize TTS after EPUB loads
    function initializeTTS() {
      // TTS initialization will be called after successful EPUB display
      populateVoices();
    }

    // Load preferences on page load
    loadPreferences();

    if (MODE === 'html' && HTML_URL) loadHTML(HTML_URL);
    else if (MODE === 'epub' && EPUB_URL) loadEPUB();
    else if (MODE === 'ia' && IA_ID) loadIA(IA_ID);
    else if (MODE === 'pdf' && PDF_URL) loadPDF(PDF_URL);
    else { bookBox.innerHTML = '<div class="muted">No content.</div>'; setStatus('error'); }

    /* ---------- Enhanced TTS with Preferences ---------- */
    const playBtn = document.getElementById('ttsPlay');
    const stopBtn = document.getElementById('ttsStop');
    const prevBtn = document.getElementById('ttsPrev');
    const nextBtn = document.getElementById('ttsNext');
    const selBtn = document.getElementById('ttsSel');
    const voiceSelect = document.getElementById('voiceSelect');
    const rateEl = document.getElementById('rate');
    const volEl = document.getElementById('vol');
    const ttsStatus = document.getElementById('ttsStatus');
    
    let isPlaying = false;
    let currentUtterance = null;
    let sentences = [];
    let currentSentenceIndex = 0;

    // Populate voice select
    function populateVoices() {
      if (!('speechSynthesis' in window)) return;
      
      const voices = speechSynthesis.getVoices();
      voiceSelect.innerHTML = '';
      
      voices.forEach((voice, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.textContent = `${voice.name} (${voice.lang})`;
        voiceSelect.appendChild(option);
      });
      
      // Restore saved voice preference
      const savedVoice = localStorage.getItem(STORAGE_KEYS.TTS_VOICE);
      if (savedVoice && voiceSelect.querySelector(`option[value="${savedVoice}"]`)) {
        voiceSelect.value = savedVoice;
      }
    }

    // Initialize voices (will be called after EPUB loads)
    if ('speechSynthesis' in window) {
      speechSynthesis.onvoiceschanged = populateVoices;
    }

    // Save TTS preferences when changed
    rateEl.addEventListener('input', () => {
      savePreferences(STORAGE_KEYS.TTS_RATE, rateEl.value);
    });
    
    volEl.addEventListener('input', () => {
      savePreferences(STORAGE_KEYS.TTS_VOLUME, volEl.value);
    });
    
    voiceSelect.addEventListener('change', () => {
      savePreferences(STORAGE_KEYS.TTS_VOICE, voiceSelect.value);
    });

    function updateStatus(status) {
      ttsStatus.textContent = status;
      isPlaying = status === 'reading';
      playBtn.textContent = isPlaying ? '‚è∏ Pause' : '‚ñ∂ Play';
    }

    function getCurrentText() {
      // Try to get selected text first
      const selection = window.getSelection();
      if (selection && selection.toString().trim()) {
        return selection.toString().trim();
      }
      
      // For EPUB, try to get current page text
      if (rendition && rendition.currentLocation) {
        try {
          const location = rendition.currentLocation();
          if (location && location.start) {
            return book.locations.get(location.start).then(loc => {
              return loc.content || '';
            }).catch(() => {
              return bookBox.innerText.replace(/\s+/g, ' ').trim().slice(0, 8000);
            });
          }
        } catch (e) {
          console.log('Could not get EPUB location, using fallback');
        }
      }
      
      // Fallback to visible text
      return bookBox.innerText.replace(/\s+/g, ' ').trim().slice(0, 8000);
    }

    function splitIntoSentences(text) {
      return text.split(/[.!?]+/).filter(s => s.trim().length > 0);
    }

    function speak(text, options = {}) {
      if (!('speechSynthesis' in window)) return;
      
      // Cancel any ongoing speech
      window.speechSynthesis.cancel();
      
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.rate = parseFloat(rateEl.value || '1');
      utterance.volume = parseFloat(volEl.value || '0.9');
      
      if (voiceSelect.value) {
        const voices = speechSynthesis.getVoices();
        utterance.voice = voices[parseInt(voiceSelect.value)];
      }
      
      utterance.onstart = () => updateStatus('reading');
      utterance.onend = () => updateStatus('ready');
      utterance.onerror = () => updateStatus('error');
      
      currentUtterance = utterance;
      window.speechSynthesis.speak(utterance);
    }

    function speakCurrentPage() {
      const text = getCurrentText();
      if (typeof text === 'string') {
        sentences = splitIntoSentences(text);
        currentSentenceIndex = 0;
        if (sentences.length > 0) {
          speak(sentences[0]);
        }
      } else {
        // Handle promise from EPUB location
        text.then(t => {
          sentences = splitIntoSentences(t);
          currentSentenceIndex = 0;
          if (sentences.length > 0) {
            speak(sentences[0]);
          }
        });
      }
    }

    function speakNextSentence() {
      if (sentences.length === 0) {
        speakCurrentPage();
        return;
      }
      
      currentSentenceIndex = Math.min(currentSentenceIndex + 1, sentences.length - 1);
      if (sentences[currentSentenceIndex]) {
        speak(sentences[currentSentenceIndex]);
      }
    }

    function speakPrevSentence() {
      if (sentences.length === 0) {
        speakCurrentPage();
        return;
      }
      
      currentSentenceIndex = Math.max(currentSentenceIndex - 1, 0);
      if (sentences[currentSentenceIndex]) {
        speak(sentences[currentSentenceIndex]);
      }
    }

    function togglePlayPause() {
      if (isPlaying) {
        window.speechSynthesis.pause();
        updateStatus('paused');
      } else if (window.speechSynthesis.speaking) {
        window.speechSynthesis.resume();
        updateStatus('reading');
      } else {
        speakCurrentPage();
      }
    }

    // Event listeners
    playBtn.addEventListener('click', togglePlayPause);
    stopBtn.addEventListener('click', () => {
      window.speechSynthesis.cancel();
      updateStatus('ready');
    });
    prevBtn.addEventListener('click', speakPrevSentence);
    nextBtn.addEventListener('click', speakNextSentence);
    selBtn.addEventListener('click', () => {
      const selection = window.getSelection();
      if (selection && selection.toString().trim()) {
        speak(selection.toString().trim());
      }
    });

    // Enhanced keyboard shortcuts with page navigation
    document.addEventListener('keydown', (e) => {
      // Don't interfere with form inputs
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') return;
      
      let handled = false;
      
      switch(e.key) {
        case ' ':
          e.preventDefault();
          togglePlayPause();
          handled = true;
          break;
        case 'Escape':
          e.preventDefault();
          window.speechSynthesis.cancel();
          updateStatus('ready');
          handled = true;
          break;
        case 'ArrowLeft':
          if (e.ctrlKey || e.metaKey) {
            // Ctrl/Cmd + Left = Previous page
            e.preventDefault();
            navigatePrev();
            handled = true;
          } else {
            // Left arrow = Previous sentence
            e.preventDefault();
            speakPrevSentence();
            handled = true;
          }
          break;
        case 'ArrowRight':
          if (e.ctrlKey || e.metaKey) {
            // Ctrl/Cmd + Right = Next page
            e.preventDefault();
            navigateNext();
            handled = true;
          } else {
            // Right arrow = Next sentence
            e.preventDefault();
            speakNextSentence();
            handled = true;
          }
          break;
        case 's':
        case 'S':
          e.preventDefault();
          const selection = window.getSelection();
          if (selection && selection.toString().trim()) {
            speak(selection.toString().trim());
          }
          handled = true;
          break;
        case 'Home':
          // Go to beginning of book
          if (rendition && rendition.display) {
            e.preventDefault();
            rendition.display();
            handled = true;
          }
          break;
        case 'End':
          // Go to end of book
          if (book && book.locations) {
            e.preventDefault();
            book.locations.generate().then(() => {
              const total = book.locations.total;
              if (total > 0) {
                rendition.display(book.locations.get(total - 1));
              }
            });
            handled = true;
          }
          break;
      }
      
      // Prevent page scrolling for handled shortcuts
      if (handled) {
        e.stopPropagation();
      }
    });
  </script>
</body>
</html>
