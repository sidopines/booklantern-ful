<!DOCTYPE html>
<html lang="en">
<head>
  <% // Safe page meta defaults %>
  <% const pTitle = (typeof pageTitle !== 'undefined' && pageTitle) ? pageTitle : 'Book | Reader'; %>
  <% const pDesc  = (typeof pageDescription !== 'undefined' && pageDescription) ? pageDescription : 'Read in a clean, paginated reader.'; %>
  <%- include('./partials/head.ejs', { pageTitle: pTitle, pageDescription: pDesc }) %>

  <style>
    :root{
      --bg:#ffffff; --paper:#ffffff; --ink:#0b1220; --muted:#667085;
      --ui:#f2f4f7; --accent:#4763ff; --accent-ink:#fff;
      --page-w: 760px; --page-h: calc(100vh - 170px); --radius: 14px;
      --font-size: 18px; --line: 1.6;
    }
    body.theme-sepia { --bg:#f9f6f1; --paper:#fbf7ef; --ink:#2b1d10; }
    body.theme-dark  { --bg:#0b1220; --paper:#0f172a; --ink:#e5e7eb; --ui:#111827; --muted:#9aa4b2; }

    body { background: var(--bg); color: var(--ink); }
    .reader-wrap { max-width: calc(var(--page-w) + 2rem); margin: 0 auto 2rem; padding: 0 1rem; }
    .toolbar {
      position: sticky; top: 0; z-index: 20; background: linear-gradient(var(--bg), var(--bg));
      padding: 12px 0; display: flex; align-items: center; gap: .6rem; flex-wrap: wrap;
      border-bottom: 1px solid rgba(0,0,0,.06);
    }
    .btn, .chip {
      display: inline-flex; align-items: center; justify-content: center; gap: .35rem;
      padding: .55rem .7rem; border: 1px solid rgba(0,0,0,.08); border-radius: 10px;
      background: var(--paper); color: var(--ink); cursor: pointer; user-select: none;
    }
    .btn:hover { background: var(--ui); }
    .btn.primary { background: var(--accent); color: var(--accent-ink); border-color: transparent; }
    .title { font-weight: 700; margin-right: auto; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 52vw; }
    .range { display: inline-flex; align-items: center; gap: .4rem; }
    .range input[type="range"]{ width: 240px; }

    /* Shared page chrome */
    .page-shell{
      width: 100%; display: flex; justify-content: center; margin-top: 12px;
    }
    .page {
      width: 100%; max-width: var(--page-w); height: var(--page-h);
      background: var(--paper); border: 1px solid rgba(0,0,0,.08); border-radius: var(--radius);
      box-shadow: 0 20px 60px rgba(0,0,0,.10); overflow: hidden; position: relative;
    }

    /* ePub.js surface */
    #epub-root { display: none; }
    #epub-view { width: 100%; height: 100%; }

    /* Fallback HTML/TXT pages (client-paginated) */
    #html-root { display: none; }
    #html-page{
      width: 100%; height: 100%; overflow: auto; padding: 28px 34px;
      font-size: var(--font-size); line-height: var(--line);
    }
    #html-page h1, #html-page h2, #html-page h3 { margin: 1.2em 0 .5em; line-height: 1.25; }
    #html-page p, #html-page li, #html-page blockquote { margin: .8em 0; }
    #html-page blockquote { padding-left: 1em; border-left: 3px solid rgba(0,0,0,.12); }
    .meta-bar { color: var(--muted); font-size: .9rem; padding: .4rem 0 .6rem; }

    /* Nav arrows for keyboard/mouse */
    .nav-arrow{
      position: absolute; top: 50%; transform: translateY(-50%); background: rgba(0,0,0,.06);
      border: 0; width: 34px; height: 34px; border-radius: 999px; cursor: pointer;
      display: grid; place-items: center; color: var(--ink);
    }
    .nav-arrow:hover{ background: rgba(0,0,0,.12); }
    .left { left: 8px; } .right{ right: 8px; }

    @media (max-width: 880px){
      :root{ --page-w: 100%; --page-h: calc(100vh - 210px); }
      .title { max-width: 45vw; }
      .range input[type="range"]{ width: 160px; }
    }
  </style>
</head>
<body class="theme-light">
  <%- include('./partials/navbar.ejs') %>

  <div class="reader-wrap">
    <div class="toolbar" role="toolbar" aria-label="Reader controls">
      <button class="btn" id="backBtn" title="Back">← Back</button>
      <div class="title" id="bookTitle">Book</div>

      <div class="range" aria-label="Progress">
        <button class="btn" id="prevBtn" title="Previous page">←</button>
        <input type="range" min="0" max="1000" step="1" value="0" id="progress">
        <button class="btn" id="nextBtn" title="Next page">→</button>
      </div>

      <div class="range" aria-label="Text size">
        <button class="btn" id="smaller">A−</button>
        <button class="btn" id="larger">A+</button>
      </div>

      <div class="range" aria-label="Theme">
        <button class="btn" id="theme">Light</button>
      </div>

      <button class="btn primary" id="listen">▶ Listen</button>
      <span id="loc" class="meta-bar"></span>
    </div>

    <!-- ePub surface -->
    <div id="epub-root" class="page-shell" aria-live="polite">
      <div class="page">
        <div id="epub-view"></div>
        <button class="nav-arrow left" id="epubPrev" title="Previous">←</button>
        <button class="nav-arrow right" id="epubNext" title="Next">→</button>
      </div>
    </div>

    <!-- Fallback HTML/TXT surface -->
    <div id="html-root" class="page-shell" aria-live="polite">
      <div class="page">
        <div id="html-page"></div>
        <button class="nav-arrow left" id="htmlPrev" title="Previous">←</button>
        <button class="nav-arrow right" id="htmlNext" title="Next">→</button>
      </div>
    </div>
  </div>

  <!-- ePub.js (only used if the ePub proxy loads) -->
  <script src="https://cdn.jsdelivr.net/npm/epubjs@0.3/dist/epub.min.js"></script>
  <script>
    (function(){
      const GID = '<%= gid %>';
      const forceText = new URLSearchParams(location.search).get('force') === 'text';

      const $ = (sel) => document.querySelector(sel);
      const byId = (id) => document.getElementById(id);

      const backBtn   = byId('backBtn');
      const prevBtn   = byId('prevBtn');
      const nextBtn   = byId('nextBtn');
      const smaller   = byId('smaller');
      const larger    = byId('larger');
      const themeBtn  = byId('theme');
      const listenBtn = byId('listen');
      const progress  = byId('progress');
      const titleEl   = byId('bookTitle');
      const locEl     = byId('loc');

      const epubRoot  = byId('epub-root');
      const epubView  = byId('epub-view');
      const epubPrev  = byId('epubPrev');
      const epubNext  = byId('epubNext');

      const htmlRoot  = byId('html-root');
      const htmlPage  = byId('html-page');
      const htmlPrev  = byId('htmlPrev');
      const htmlNext  = byId('htmlNext');

      // State
      let mode = null; // 'epub' | 'html'
      let book = null; // epub.js Book
      let rendition = null;

      // Fallback pages
      let PAGES = []; // array of HTML strings
      let pageIndex = 0;

      // TTS
      let speaking = false;
      let paused   = false;
      let currentUtterance = null;

      function setTitle(t){ if (t) titleEl.textContent = t; }
      function setLocText(txt){ locEl.textContent = txt || ''; }

      backBtn.onclick = () => { if (history.length > 1) history.back(); else location.href = '/read'; };

      // THEME
      const themes = ['Light','Sepia','Dark'];
      function cycleTheme(){
        const b = document.body;
        if (b.classList.contains('theme-light')) { b.classList.remove('theme-light'); b.classList.add('theme-sepia'); themeBtn.textContent = 'Sepia'; }
        else if (b.classList.contains('theme-sepia')) { b.classList.remove('theme-sepia'); b.classList.add('theme-dark'); themeBtn.textContent = 'Dark'; }
        else { b.classList.remove('theme-dark'); b.classList.add('theme-light'); themeBtn.textContent = 'Light'; }
      }
      themeBtn.onclick = cycleTheme;

      // FONT SIZE
      function fontDelta(dx){
        const curr = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--font-size'));
        const next = Math.max(14, Math.min(24, curr + dx));
        document.documentElement.style.setProperty('--font-size', next + 'px');
        if (mode === 'epub' && rendition){
          rendition.themes.fontSize(next + 'px');
        }
      }
      smaller.onclick = () => fontDelta(-2);
      larger.onclick  = () => fontDelta(+2);

      // TTS helpers
      function say(text){
        stopTTS();
        if (!text || !text.trim()) return;
        const u = new SpeechSynthesisUtterance(text);
        u.rate = 1.0;
        u.onend = () => { speaking = false; paused = false; currentUtterance = null; };
        u.onerror = () => { speaking = false; paused = false; currentUtterance = null; };
        currentUtterance = u;
        speaking = true; paused = false;
        speechSynthesis.speak(u);
      }
      function stopTTS(){ if (speechSynthesis.speaking) speechSynthesis.cancel(); speaking=false; paused=false; currentUtterance=null; }
      function toggleListen(){
        if (mode === 'epub' && rendition){
          const contents = rendition.getContents();
          if (contents && contents[0] && contents[0].document){
            const txt = contents[0].document.body ? contents[0].document.body.innerText : '';
            if (!speaking) { say(txt); listenBtn.textContent = '⏸ Pause'; }
            else if (!paused) { speechSynthesis.pause(); paused = true; listenBtn.textContent = '▶ Resume'; }
            else { speechSynthesis.resume(); paused = false; listenBtn.textContent = '⏸ Pause'; }
          }
          return;
        }
        // HTML fallback
        const page = byId('page-'+pageIndex);
        const txt  = page ? page.innerText : '';
        if (!speaking) { say(txt); listenBtn.textContent = '⏸ Pause'; }
        else if (!paused) { speechSynthesis.pause(); paused = true; listenBtn.textContent = '▶ Resume'; }
        else { speechSynthesis.resume(); paused = false; listenBtn.textContent = '⏸ Pause'; }
      }
      listenBtn.onclick = toggleListen;

      // EPUB LOADER
      async function tryLoadEpub(){
        try{
          const url = `/proxy/gutenberg-epub/${encodeURIComponent(GID)}`;
          const res = await fetch(url, { cache:'no-store' });
          if (!res.ok) throw new Error('no epub');
          const blob = await res.blob();
          const objURL = URL.createObjectURL(blob);

          book = ePub(objURL);
          rendition = book.renderTo(epubView, { width: '100%', height: '100%' });
          rendition.display();

          // Theme + font inside ePub
          const fontSize = getComputedStyle(document.documentElement).getPropertyValue('--font-size').trim();
          const isDark   = document.body.classList.contains('theme-dark');
          rendition.themes.register('booklantern', {
            body: {
              'background': getComputedStyle(document.documentElement).getPropertyValue('--paper').trim(),
              'color': getComputedStyle(document.documentElement).getPropertyValue('--ink').trim(),
              'line-height': '1.6',
              'font-size': fontSize || '18px',
            }
          });
          rendition.themes.select('booklantern');

          epubPrev.onclick = () => { stopTTS(); rendition.prev(); };
          epubNext.onclick = () => { stopTTS(); rendition.next(); };

          rendition.on('relocated', (loc) => {
            if (book && book.locations && book.locations.length() > 0){
              const p = Math.round(book.locations.percentageFromCfi(loc.start.cfi) * 1000);
              progress.value = isNaN(p) ? 0 : p;
              setLocText('Location ' + (progress.value/10).toFixed(1) + '%');
            }
          });

          // Build locations (may take a moment)
          book.ready.then(() => book.locations.generate(1600)).catch(()=>{});
          book.loaded.metadata.then(meta => setTitle(meta.title || 'Book'));

          progress.oninput = (e) => {
            if (!book) return;
            const pct = (Number(progress.value) || 0) / 1000;
            if (book.locations && book.locations.cfiFromPercentage){
              const cfi = book.locations.cfiFromPercentage(pct);
              stopTTS();
              rendition.display(cfi);
            }
          };

          // Keyboard
          window.addEventListener('keydown',(ev)=>{
            if (ev.key === 'ArrowLeft'){ epubPrev.click(); }
            if (ev.key === 'ArrowRight'){ epubNext.click(); }
          });

          epubRoot.style.display = 'flex';
          mode = 'epub';
          return true;
        }catch(e){
          return false;
        }
      }

      // ---- FALLBACK HTML/TXT ----
      function sanitizeHTML(html){
        const doc = new DOMParser().parseFromString(html, 'text/html');
        // Remove styles/scripts/links
        doc.querySelectorAll('script,style,link,meta,iframe,noscript').forEach(n=>n.remove());
        // Flatten some Gutenberg wrappers
        return doc.body.innerHTML;
      }
      function chunkHTMLToPages(html){
        // Convert to nodes and then chunk by character count for simplicity.
        const tmp = document.createElement('div');
        tmp.innerHTML = html;
        const blocks = [];
        tmp.querySelectorAll('h1,h2,h3,h4,h5,h6,p,li,blockquote,pre').forEach(el=>{
          const t = el.outerHTML || '';
          if (t.trim()) blocks.push(t);
        });
        const joined = blocks.join('\n');
        const pages = [];
        const SIZE = 1800; // ~1–2 minutes reading per page
        for (let i=0; i<joined.length; i+=SIZE){
          pages.push(joined.slice(i, i+SIZE));
        }
        return pages.length ? pages : ['<p>(No content)</p>'];
      }
      function chunkTextToPages(text){
        const paras = String(text || '').split(/\n{2,}/).map(s=>`<p>${s.replace(/</g,'&lt;')}</p>`);
        const joined = paras.join('\n');
        const pages = [];
        const SIZE = 1800;
        for (let i=0; i<joined.length; i+=SIZE){
          pages.push(joined.slice(i, i+SIZE));
        }
        return pages.length ? pages : ['<p>(No content)</p>'];
      }
      function renderFallbackPages(pages, title){
        PAGES = pages;
        pageIndex = 0;
        setTitle(title || 'Book');
        drawPage();
        htmlRoot.style.display = 'flex';
        mode = 'html';
      }
      function drawPage(){
        htmlPage.innerHTML = `<div id="page-${pageIndex}">${PAGES[pageIndex]}</div>`;
        const pct = Math.round((pageIndex / Math.max(1, PAGES.length-1)) * 1000);
        progress.value = pct;
        setLocText(`Page ${pageIndex+1} / ${PAGES.length}`);
        listenBtn.textContent = '▶ Listen';
      }
      function nextPage(){
        if (pageIndex < PAGES.length-1){ pageIndex++; stopTTS(); drawPage(); }
      }
      function prevPage(){
        if (pageIndex > 0){ pageIndex--; stopTTS(); drawPage(); }
      }

      htmlNext.onclick = nextPage;
      htmlPrev.onclick = prevPage;
      progress.oninput = (e)=>{
        if (mode!=='html') return;
        const pct = Number(progress.value)/1000;
        pageIndex = Math.max(0, Math.min(PAGES.length-1, Math.round(pct * (PAGES.length-1))));
        stopTTS();
        drawPage();
      };
      window.addEventListener('keydown',(ev)=>{
        if (mode!=='html') return;
        if (ev.key === 'ArrowLeft') prevPage();
        if (ev.key === 'ArrowRight') nextPage();
      });

      async function loadFallback(){
        try{
          const r = await fetch(`/read/gutenberg/${encodeURIComponent(GID)}/text`, { cache:'no-store' });
          const data = await r.json();
          const title = data.title || 'Book';
          if (data.type === 'html'){
            const clean = sanitizeHTML(data.content || '');
            const pages = chunkHTMLToPages(clean);
            renderFallbackPages(pages, title);
          }else{
            const pages = chunkTextToPages(data.content || '');
            renderFallbackPages(pages, title);
          }
        }catch(e){
          htmlRoot.style.display = 'flex';
          htmlPage.innerHTML = '<div class="meta-bar">Could not load this title right now.</div>';
        }
      }

      // WIRE primary prev/next (toolbar)
      prevBtn.onclick = () => (mode==='epub' ? epubPrev.click() : htmlPrev.click());
      nextBtn.onclick = () => (mode==='epub' ? epubNext.click() : htmlNext.click());

      // Start
      (async function boot(){
        if (forceText){
          await loadFallback();
          return;
        }
        const ok = await tryLoadEpub();
        if (!ok) await loadFallback();
      })();
    })();
  </script>
</body>
</html>
